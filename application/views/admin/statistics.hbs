<div class="admin-list">
    {{>admin_header}}
    {{>adminNavigation}}
    <div class="content" id="statistics">
        <h2>Statistics and Reports</h2>
        <div class="header-option form-inline">
            <div class="form-group">
                <label for="type">Type</label>
                <select name="type" id="type">
                    <option value="date">Date</option>
                    <option value="month">Month</option>
                    <option value="year">Year</option>
                </select>
                <label for="report">Statistics</label>
                <select name="report" id="report">
                    {{#each report}}
                    <option value={{this}}>{{this}}</option>
                    {{/each}}
                </select>
                <label for="label">Label</label>
                <select name="label" id="label">
                    <option value="all" selected>All</option>
                    <option value="0">Normal</option>
                    <option value="1">Malware</option>
                </select>
            </div>
        </div>
        <div class="data-content">
            <canvas id="fanChart"></canvas>
            <canvas id="lineChart"></canvas>
            <div id="listChart">
                <h4>List log</h4>
                <table class="table table-hover table-bordered" id="list_log">
                    <thead class="thead-dark">
                        <tr>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
                </table>
                <nav aria-label="Page navigation example">
                    <ul class="pagination" id="report-pagination">
                    </ul>
                </nav>
            </div>
        </div>
    </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-datalabels/2.2.0/chartjs-plugin-datalabels.min.js" integrity="sha512-JPcRR8yFa8mmCsfrw4TNte1ZvF1e3+1SdGMslZvmrzDYxS69J7J49vkFL8u6u8PlPJK+H3voElBtUCzaXj+6ig==" crossorigin="anonymous" referrerpolicy="no-referrer"></script> 
{{!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.1/chart.min.js"></script> --}}
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.2/moment.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-adapter-moment/1.0.0/chartjs-adapter-moment.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-zoom/2.0.1/chartjs-plugin-zoom.min.js" integrity="sha512-wUYbRPLV5zs6IqvWd88HIqZU/b8TBx+I8LEioQ/UC0t5EMCLApqhIAnUg7EsAzdbhhdgW07TqYDdH3QEXRcPOQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
    var type = document.getElementById('type');
    var report=document.getElementById('report')
    var label=document.getElementById('label')
    var pagination=document.getElementById('report-pagination')
    var fan_chart = null;
    var line_chart = null;
    async function fetchReport(type){
        await fetch(`/admin/statistics/date?type=${type}`,
                {
                    headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' },
                    method: "GET",
                })
                .then(async (response) => { 
                    data=await response.json()
                    for (var i = 0; i<data.length; i++){
                        var opt = document.createElement('option');
                        opt.value = data[i];
                        opt.innerHTML = data[i];
                        report.appendChild(opt);
                    }
                });
    }
    async function fetchData(){
        console.log(label.value)
        fetch(`/admin/statistics/data?type=${type.value}&date=${report.value}&label=${label.value}`,
                {
                    headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' },
                    method: "GET",
                })
                .then((response) => { 
                    return response.json().then((data) => {
                        fanChart(data.all_data)
                        handlePagination(data.all_data,1)
                        lineChart(data.bound_data)
                    }).catch((err) => {
                        console.log(err);
                    }) 
                });
    }
    document.addEventListener('DOMContentLoaded', async function () {
        await fetchReport('date')
        fetchData()      
    })
    type.addEventListener('change', async function() {
        report.length = 0;
        await fetchReport(this.value)
        fetchData()
    }, false);
    report.addEventListener('change', function() {
        fetchData()
    }, false);
    label.addEventListener('change', async function(){
        fetchData()
    })
    async function fanChart(data){
        var ctx = document.getElementById("fanChart")
        if(fan_chart){
            fan_chart.clear();
            fan_chart.destroy();
        }
        let labels={0:0,1:0}
        data.forEach(function (log) {
            labels[log.label]+=1
        });
        var xValues = Object.keys(labels);
        var yValues = Object.values(labels);
        xValues=xValues.map((item) => {
            if (item==1) return 'malware'
            else if (item==0) return 'normal'
        })
        var barColors = [
        "#90EE90",
        "#FA5F55",
        ];
        fan_chart=new Chart(ctx, {
            type: "pie",
            data: {
                labels: xValues,
                datasets: [{
                backgroundColor: barColors,
                data: yValues,
                datalabels:{
                    formatter: (value, ctx) => {
                        let sum = 0;
                        let dataArr = ctx.chart.data.datasets[0].data;
                        dataArr.map(data => {
                            sum += data;
                        });
                        let percentage = (value*100 / sum).toFixed(2)+"%";
                        return percentage;
                    },
                    color: '#fff',
                    
                }
                }]
            },
            options: {
                responsive: false,
                devicePixelRatio: 4,
                tooltips: {
                    enabled: true
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'RATIO MALWARE TRAFFIC DASHBOARD',
                    },
                    
                }
            },
            plugins: [ChartDataLabels]
        });
    }
    async function handlePagination(data, indexPage){
        pagination.replaceChildren();
        let maxPage=Math.ceil((data.length)/10);
        indexPage=parseInt(indexPage);
        ['Previous',indexPage-1,indexPage, indexPage+1,'Next'].forEach((item)=>{
            let li= document.createElement("li");
            li.classList.add('page-item')
            if (item==indexPage){
                li.classList.add('active')
            }
            let a=document.createElement('a')
            a.classList.add('page-link')
            a.innerHTML=item
            li.appendChild(a)
            li.addEventListener("click", function () {
                if(a.innerText=='Previous'){
                    handlePagination(data,indexPage-2)
                }
                else if(a.innerText=='Next'){
                    handlePagination(data,indexPage+2)
                }
                else{
                    handlePagination(data,a.innerText)
                }
            })
            pagination.appendChild(li)
        })
        var pageLoad = document.getElementsByClassName('page-item');
        if (pageLoad[1].innerText == 0 || pageLoad[1].innerText < 0) {
            pageLoad[0].classList.add('none');
            pageLoad[1].classList.add('none');
        };
        if (pageLoad[1].innerText == 1) {
            pageLoad[0].classList.add('none')
        };
        if (pageLoad[2].innerText == maxPage | pageLoad[2].innerText > maxPage) {
            pageLoad[3].classList.add('none');
            pageLoad[4].classList.add('none');
        };
        if (pageLoad[3].innerText == maxPage) {
            pageLoad[4].classList.add('none');
        };
        fillTableData(data, indexPage)
    }
    async function fillTableData(data, page){
        head_tr=document.querySelector('#list_log thead tr')
        head_tr.replaceChildren()
        const keys = ['Time','Source Address','Destination Address','Protocol','Label']
        keys.forEach(item=>{
            th=document.createElement('th')
            th.setAttribute("scope", "col");
            th.innerText=item
            head_tr.appendChild(th)
        })
        body=document.querySelector('#list_log tbody')
        body.replaceChildren();
        max_value_page = (data.length<page*10) ? data.length : page*10
        for(i=(page-1)*10;i<max_value_page;i++){
            item=data[i]
            connection_index=item['connection_index'].split(',')
            label_str=(item['label']==0)?'normal':'malware'
            body_tr=document.createElement('tr')
            body.appendChild(body_tr)
            values=[item['ts'],connection_index[0],connection_index[1],connection_index[3],label_str]
            values.forEach((v,i)=>{
                td=document.createElement('td')
                td.innerText=v
                body_tr.appendChild(td)
            })
        }
    }
    async function lineChart(data){
        var data = data.sort(function(a, b) {
            return new Date(a.ts) - new Date(b.ts)
        })
        if(line_chart){
            line_chart.clear();
            line_chart.destroy();
        }
        var ctx = document.getElementById("lineChart").getContext('2d')
        let inbound=[]
        let outbound=[]
        data.forEach((item)=>{
            inbound.push({x:item['ts'],y:item['inbound']})
            outbound.push({x:item['ts'],y:item['outbound']})
        })
        /*new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [{
                label: 'My Dataset',
                data: inbound,
                showLine: true,
                lineTension: 0.3,
                borderColor: 'rgb(100, 100, 255)'
                }],
            },
            options: {
                scales: {
                x: {
                    type: 'time',
                    
                },               
                }
            }
            });*/
        const totalDuration = 10000;
        const delayBetweenPoints = totalDuration / data.length;
        const previousY = (ctx) => ctx.index === 0 ? ctx.chart.scales.y.getPixelForValue(100) : ctx.chart.getDatasetMeta(ctx.datasetIndex).data[ctx.index - 1].getProps(['y'], true).y;
        const animation = {
        x: {
            type: 'number',
            easing: 'linear',
            duration: delayBetweenPoints,
            from: NaN, // the point is initially skipped
            delay(ctx) {
            if (ctx.type !== 'data' || ctx.xStarted) {
                return 0;
            }
            ctx.xStarted = true;
            return ctx.index * delayBetweenPoints;
            }
        },
        y: {
            type: 'number',
            easing: 'linear',
            duration: delayBetweenPoints,
            from: previousY,
            delay(ctx) {
            if (ctx.type !== 'data' || ctx.yStarted) {
                return 0;
            }
            ctx.yStarted = true;
            return ctx.index * delayBetweenPoints;
            }
        }
        };

        // Config-----
        const config = {
            type: 'line',
            data: {
                datasets: [{
                    label:'inbound',
                    borderColor: "#ff0000",
                    borderWidth: 1,
                    radius: 0,
                    data: inbound,
                    
                },
                    {
                        label:'outbound',
                        borderColor: "#00FFFF",
                        borderWidth: 1,
                        radius: 0,
                        data: outbound,
                        
                    }]
            },
            options: {
                responsive: false,
                devicePixelRatio: 4,
                tooltips: {
                    enabled: true
                },
                indexAxis: 'x',
                //animation,
                interaction: {
                    intersect: false
                },
                plugins: {
                    title: {
                            display: true,
                            text: 'INBOUND AND OUTBOUND TRAFFIC DASHBOARD',
                        },
                    zoom: {
                        zoom: {
                            wheel: {
                                enabled: true,
                            },
                            pinch: {
                                enabled: true
                            },
                            mode: 'xy',
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        
                    },              
                    }
            }
        };
        // Config-----


        line_chart = new Chart(
            ctx,
            config
        );
    }
    
</script>