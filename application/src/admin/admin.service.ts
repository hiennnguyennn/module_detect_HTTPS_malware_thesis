import {
  Inject,
  Injectable,
  forwardRef,
} 
  from '@nestjs/common';
import fs = require('fs');
import readline = require('readline');
import path = require('node:path')
import shell= require('shelljs');
import { InjectRepository } from '@nestjs/typeorm';
import { Log } from './entity/log.entity';
import { Repository } from 'typeorm';
import { RedisCacheService } from 'src/redis_cache/redis.service';
import moment = require('moment');
import { Train } from './entity/train.entity';
import { AuthService } from 'src/auth/auth.service';
import { MailService } from 'src/mail/mail.service';

@Injectable()
export class AdminService {
  constructor(@InjectRepository(Log) private logRepository: Repository<Log>,
    // @InjectRepository(Log) private trainRepository: Repository<Train>,
    private readonly redisCacheService: RedisCacheService,
    private readonly mailService: MailService,
    private readonly authService: AuthService
  ){}
  list_pid: number[]=[];
  pid_train:number;
  Slips_directory=process.cwd().split('/').slice(0,-1).join('/')+'/StratosphereLinuxIPS'

  //update configuration file
  async updateConfig(config){
    let config_data = await fs.readFileSync(this.Slips_directory+'/config/slips.conf').toString();
    let edited=['#interfaces', 'home_network','pcapfilter','rotation_period']
    for(var i=0; i<edited.length;i++){
      let key=edited[i]
      if(edited[i]=='#interfaces'){
        key='interfaces'
        config[key]='['+config[key].toString()+']'
      }
      if(!config[key]){
        config_data=this.editValueByKey(config_data, edited[i],'')
      }
      else{
        config_data=this.editValueByKey(config_data, edited[i],edited[i]+" = " +config[key])
      }
      
    } 
    await fs.writeFileSync(this.Slips_directory+'/config/slips.conf', config_data)
    console.log('Done')
    return true
  }

  getValueByKey(text, key){
    var regex = new RegExp("^" + key + " = (.*)$", "m");
    var match = regex.exec(text);
    if(match)
      return match[1];
    else{
      return null;
    }
        
  }
  editValueByKey(text, key, value){
    var regex = new RegExp("^" + key + " = (.*)$", "m");
    var match = regex.exec(text);
    if(match){
      console.log('regex match '+key)
      text = text.replace(regex, value);
    }
    else if (value!=""){
      console.log('regex not match '+key)
      text=text+"\n"+value
    }
    return text
  }

  //read some data from configuration file
  async readConfig(){
    const config_data = await fs.readFileSync(this.Slips_directory+'/config/slips.conf').toString();
    let data={
      interfaces: (await this.getValueByKey(config_data, '#interfaces')),
      home_network: await this.getValueByKey(config_data, 'home_network'),
      pcapfilter: await this.getValueByKey(config_data, 'pcapfilter'),
      rotation_period: await this.getValueByKey(config_data, 'rotation_period'),
    }
    return data
  }

  //get list interface on device
  async get_interfaces(){
    let ifconfig_result=await shell.exec('ifconfig').toString();
    ifconfig_result=ifconfig_result.split("\n\n")
    let list_result=[]
    for (var i=0;i<ifconfig_result.length;i++){
      var itf=ifconfig_result[i].split(":")[0]
      var regex= new RegExp("inet (.*) netmask")
      let ip=regex.exec(ifconfig_result[i])
      if(ip!=null){
        let tmp={
          interface: itf,
          ip: ip[1]
        }
        list_result.push(tmp)
      }
    }
    return list_result
  }

  //start detect
  async detect(){
    let config_data = await fs.readFileSync(this.Slips_directory+'/config/slips.conf').toString();
    let mode=await this.getValueByKey(config_data, 'mode')
    if (mode=='train'){
      config_data=this.editValueByKey(config_data, 'mode',"mode = test")
      await fs.writeFileSync(this.Slips_directory+'/config/slips.conf', config_data)
    }
    let interfaces_config= await this.getValueByKey(config_data, '#interfaces')
    let list_interfaces_config= (""+interfaces_config.replace(/[\[\]]/g,'')).split(',')
    var ls=new Array(list_interfaces_config.length)
    for(var i=0; i<list_interfaces_config.length;i++){
      ls[i]=require('child_process').spawn('./slips.py', ['-m','-c', 'config/slips.conf', '-i', list_interfaces_config[i].toString()],{cwd:this.Slips_directory,detached: true});
      this.list_pid.push(ls[i].pid)
      ls[i].unref();
    }
    this.redisCacheService.listenEventLog()
  }
  
  //stop detection
  async stop_detect(){
    let list_pid_string=this.list_pid.join(' ')
    console.log('kill process: '+list_pid_string)
    let kill_process=require('child_process').exec(`for pid in ${list_pid_string}; do kill -15 $pid; done`);
    kill_process=require('child_process').spawn('./slips.py', ['--killall','-cc'],{cwd:this.Slips_directory});
    console.log('close child process')
    kill_process.kill()
    this.redisCacheService.stop()
  }

  async saveLog(logData){
    console.log('data: '+logData['connection_data']['connection_index'])
    logData['connection_data']['connection_index']=logData['connection_data']['connection_index'].join(',')
    let tmp=logData['connection_data']
    tmp['label']=Number(logData['predict'])
    tmp['seen']=false
    tmp['ts']=await this.formatDatetime(logData['time'])
    tmp['directory']=path.join(this.Slips_directory,logData['folder'])
    // if (tmp['label']==1){
    //   const connection_index=tmp['connection_index'].split(',')
    //   console.log(1111, connection_index)
    //   this.sendMail(connection_index[0],connection_index[1])
    // }
    return this.logRepository.save(tmp)
  }

  async getAllEventData(){
    return this.redisCacheService.getAllData()
  }

  async formatDatetime(unixtime){
    return moment.unix(unixtime).format('YYYY-MM-DD HH:mm:ss')
    // var ts_ms = unixtime * 1000;
    // var date_ob = new Date(ts_ms);
    // var year = date_ob.getFullYear();
    // var month = ("0" + (date_ob.getMonth() + 1)).slice(-2);
    // var date = ("0" + date_ob.getDate()).slice(-2);
    // var hours = ("0" + date_ob.getHours()).slice(-2);
    // var minutes = ("0" + date_ob.getMinutes()).slice(-2);
    // var seconds = ("0" + date_ob.getSeconds()).slice(-2); 
    // var result= year + "-" + month + "-" + date + " " + hours + ":" + minutes + ":" + seconds;
    // return result
  }

  async getNoti(){
    let result=await this.logRepository.createQueryBuilder('log').select('log.connection_index').addSelect('log.label').addSelect('log.seen').addSelect('log.ts').where('log.label=1').orderBy('ts','DESC').getMany()
    let number_unseen=0
    for(var i=0;i<result.length;i++){
      if (result[i]['seen']==false){
        number_unseen+=1
      }
      //result[i]['ts']=await this.formatDatetime(result[i]['ts'])
    }
    this.logRepository.update({}, { seen: false })
    return {'number_unseen':number_unseen, 'result':result} 
  }

  async saveDBTrain(data, file){
    let currentDate = moment().format('DD-MM-YYYY_HH:mm:ss');
    let pcap_dir=path.join(this.Slips_directory,'dataset',data['name']+currentDate)
    fs.mkdirSync(pcap_dir);
    fs.rename(file.pcap[0].path, path.join(pcap_dir,'capture.pcap'),function(err){
      console.log("Successfully moved the file!");
    })
    let ips_string=""
    if (data.malware){
      let list_malware=data.malware.split(',')
      list_malware.forEach(element => {
        ips_string+=element.toString()+'\t'+'malware'+'\n'
      });
    }
    if (data.normal){
      let list_normal=data.normal.split(',')
      list_normal.forEach(element => {
        ips_string+=element.toString()+'\t'+'normal'+'\n'
      });
    }
 
    let regex = /^\s*$(?:\r\n?|\n)/gm;
    ips_string = ips_string.replace(regex, "");
    try {
      fs.writeFileSync(path.join(pcap_dir,'ips.log'), ips_string);
    } catch (err) {
      console.error(err);
    }
    return pcap_dir
  }

  async trainModel(data, file){
    let config_data = await fs.readFileSync(this.Slips_directory+'/config/slips.conf').toString();
    let mode=await this.getValueByKey(config_data, 'mode')
    if (mode=='test'){
      config_data=this.editValueByKey(config_data, 'mode',"mode = train")
      await fs.writeFileSync(this.Slips_directory+'/config/slips.conf', config_data)
    }
    let pcap_dir=await this.saveDBTrain(data, file)
    let train_process=require('child_process').spawn('./slips.py', ['-m','-c', 'config/slips.conf', '-f', path.join(pcap_dir,'capture.pcap')],{cwd:'/home/hiennnn/Documents/DATN/StratosphereLinuxIPS',detached: true});
    // this.list_pid.push(ls[i].pid)
    this.pid_train=train_process.pid
    train_process.unref();
    this.redisCacheService.listenEventTrainLog(data['name'])
    return true
  }

  async getDataTrain(){
    await this.redisCacheService.getDataTrain()
  }

  async stop_train(){
    console.log('kill process: '+this.pid_train)
    let kill_process=require('child_process').exec(`kill -15 ${this.pid_train}`);
    kill_process=require('child_process').spawn('./slips.py', ['--killall','-cc'],{cwd:this.Slips_directory});
    console.log('close child process')
    kill_process.kill()
    this.redisCacheService.stop()
  }

  // async saveTrainLog(data, name){
  //   let tmp={}
  //   tmp['name']=name
  //   tmp['ts']=data['time']
  //   tmp['acc']=Number(data['acc'])
  //   return this.trainRepository.save(tmp)
  // }

  async getDateReport(type){
    let date=await this.logRepository.createQueryBuilder('log').select('log.ts').getMany()
    let arrayDate = date.map(r => r.ts);
    switch(type) {
      case 'date':
        arrayDate.forEach((element, index) => {
          arrayDate[index]=moment(new Date(element)).format('DD-MM-YYYY');
        })
        break;
      case 'month':
        arrayDate.forEach((element, index) => {
          arrayDate[index]=moment(new Date(element)).format('MM-YYYY');
        })
        break;
      case 'year':
        arrayDate.forEach((element, index) => {
          arrayDate[index]=moment(new Date(element)).format('YYYY');
        })
        break;
    }
    arrayDate = arrayDate.filter((value, index, array) => {
      return array.indexOf(value) === index;
    });
    return arrayDate
  }

  async getDataReport(type, date,label){
    let data=[]
    switch(label){
      case 'all':
        data=await this.logRepository.createQueryBuilder('log')
            .select('log.connection_index')
            .addSelect('log.label')
            .addSelect('log.directory')
            .addSelect('log.ts')
            .orderBy("ts", "ASC")
            .getMany()
        break
      default:
        data=await this.logRepository.createQueryBuilder('log')
                  .select('log.connection_index')
                  .addSelect('log.label')
                  .addSelect('log.directory')
                  .addSelect('log.ts')
                  .where('log.label= :label', { label: label })
                  .orderBy("ts", "ASC").getMany()
        break
    }
    switch(type) {
      case 'date':
        data=data.filter(log => moment(new Date(log.ts)).format('DD-MM-YYYY') ==date);
        break;
      case 'month':
        data=data.filter(log => moment(new Date(log.ts)).format('MM-YYYY') ==date);
        break;
      case 'year':
        data=data.filter(log => moment(new Date(log.ts)).format('YYYY') ==date);
        break;
    }
    return data
  }

  async getDirectories(path) {
    return fs.readdirSync(path).filter(function (file) {
      return fs.statSync(path+'/'+file).isDirectory();
    });
  }

  async getByteInFile(data){
    let folders = data.map(r => r.directory);
    folders = folders.filter((value, index, array) => {
      return array.indexOf(value) === index;
    });
    let list_result=[]
    folders.forEach(async (folder) => {
      let list_conn_folder=await this.getDirectories(path.join(folder,'Connection_4-tuples'))
      list_conn_folder.forEach(async (conn_folder) => {
        var rl =fs.readFileSync(path.join(folder,'Connection_4-tuples',conn_folder,'conn.log')).toString('utf-8').split("\r\n");
        rl.forEach(line=>{
          if (line){
            var line_dict = JSON.parse(line);

            list_result.push({ts:moment.unix(line_dict['ts']).format('YYYY-MM-DD HH:mm:ss'),connection_index:line_dict['connection_index'],inbound:line_dict['resp_bytes'],outbound:line_dict['orig_bytes']})
          }
          
        })
      });
    });
    // list_result = Object.keys(list_result).sort(function(a, b) {
    //   return new Date(list_result[a]['ts']) - new Date(list_result[b]['ts'])
    // })
    return list_result
  }

  async sendMail(sourceIP, destIP){
    let list_user=await this.authService.getAllUser()
    list_user.forEach(u=>{
      this.mailService.sendWarningMail({'username':u.username,'sourceIP':sourceIP,'destIP':destIP,'mail':u.mail})
    })
  }
  
}
