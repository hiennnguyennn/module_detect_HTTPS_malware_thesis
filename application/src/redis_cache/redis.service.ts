import { Inject, Injectable, OnModuleDestroy, forwardRef } from "@nestjs/common";
import { RedisService } from '@liaoliaots/nestjs-redis';
// import { EventsGateway } from "./socket_event.gateway";
import Redis from 'ioredis';
import { EventsGateway } from "./socket_event.gateway";
import { AdminService } from "src/admin/admin.service";

@Injectable()
export class RedisCacheService implements OnModuleDestroy {
  private readonly client1: Redis;
  private readonly client2: Redis;

  constructor(
    
    private readonly redisService: RedisService,
    private readonly eventGateway:EventsGateway,
    @Inject(forwardRef(() => AdminService))
    private readonly adminService:AdminService
    ) {
    this.client1 = this.redisService.getClient('test1');
    this.client2 = this.redisService.getClient('test2');
  }

  onModuleDestroy() {
    this.client1.quit();
    this.client2.quit();
  }
  
  async saveCache(data){
    let key=data['uid']
    let value={'connection index':data['connection_data']['connection_index'],'prediction':data['predict'],'time':data['time']}
    this.client2.set(key, JSON.stringify(value))
  }

  async listenEventLog() {
    console.log('listen')
    this.eventGateway.startSlipsSocket()
    this.client2.set('detect','true')
    this.client1.unsubscribe('log_train')
    this.client1.subscribe('log_event') 
    this.client1.on("message", async (channel, message) => {
      console.log(111, message)
      let data=JSON.parse(message)
      this.adminService.saveLog(data)
      data['predict']=data['predict'].toString() =='0' ? 'normal' : 'malware';
      data['time'] = await this.adminService.formatDatetime(data['time'])
      this.eventGateway.handleData({'time':data['time'],'connection index':data['connection_data']['connection_index'],'prediction':data['predict']})
      this.saveCache(data)
  });
    return true
  }

  async getAllData(){
    let keys=await this.client2.keys('*')
    let all_data=""
    if (keys.includes('detect')){
      const index = keys.indexOf('detect');
      keys.splice(index, 1)
      if (keys.length>0){
        for(var i=0;i<keys.length;i++){
          console.log('keys: ', keys[i])
          let tmp=JSON.parse(await this.client2.get(keys[i]))
          all_data+=tmp['time']+': Connection index '+tmp['connection index']+'\r\nPrediction: '+tmp['prediction']+'\r\n'
        }
      }     
    }   
    return all_data
    // let status=await this.client2.get('detect')
    // let all_data=""
    // if (status=='true'){
    //   let keys=await this.client2.keys('*')
    //   if (keys.length>1){
    //     for(var i=0;i<keys.length;i++){
    //       if (keys[i]!='detect'){
    //         console.log('keys: ', keys[i])
    //         let tmp=JSON.parse(await this.client2.get(keys[i]))
    //         all_data+=tmp['time']+': Connection index '+tmp['connection index']+'\r\nPrediction: '+tmp['prediction']+'\r\n'
    //       }
    //     }
    //   }
    // }
    // return all_data
  }

  async stop(){
    await this.client2.flushall()
    await this.client1.unsubscribe()
    this.eventGateway.closeSlipsSocket()
  }

  async listenEventTrainLog(name){
    console.log('listen train log')
    this.eventGateway.startSlipsSocket()
    this.client2.set('train','true')
    this.client1.unsubscribe('log_event')
    this.client1.subscribe('log_train')
    console.log('subcribe log_train')
    this.client1.on("message", async (channel, message) => {
      console.log(message)
      let data=JSON.parse(message)
      if (data['msg']=="Done training"){
        this.eventGateway.handleData({'time':data['time'],'msg':data['msg'], 'acc':data['acc']})
      }
      else{
        this.eventGateway.handleData({'time':data['time'],'msg':data['msg']})
      }
      
      // if (data['acc']){
      //   this.adminService.saveTrainLog(data,name)
      // }
      // this.saveCacheTrain(data)
  });
    return true
  }

  async getDataTrain(){
    let keys=await this.client2.keys('*')
    if (keys.includes('train')){
      const index = keys.indexOf('train');
      keys.splice(index, 1)
      if (keys.length>0){
        for(var i=0;i<keys.length;i++){
          console.log('keys: ', keys[i])
          this.eventGateway.handleData({'time':await this.client2.get(keys[i]),'msg':keys[i]})
        }
      }     
    }   
    return true
  }

  async saveCacheTrain(data){
    this.client2.set(data['msg'], data['time'])
  }

}

