import socket
import numpy
class Connection4tuple:
  def __init__(self, tuple_index):
    self.tuple_index=tuple_index
    self.malware_label=0
    self.normal_label=0
  #list flows
    self.ssl_flow_list=[]
    self.x509_list=[]
    self.ssl_logs_list=[]
    self.malware_label=0
    self.normal_label=0

  #connection features
    self.uid_flow_dict=dict()
    self.state_of_connection_dict=dict()
    self.total_size_of_flows_orig=0
    self.total_size_of_flows_resp=0
    self.flow_which_has_duration_number=0
    self.duration_list=[]
    self.list_payload_bytes_from_resp=[]
    self.average_duration=0
    self.agverage_duration_power=0
    self.inbound_packets=0
    self.outbound_packets=0

  #ssl features
    self.ssl_uids_list=[]
    self.version_of_ssl_dict=dict()
    self.version_of_ssl_cipher_dict=dict()
    self.certificate_path=dict()
    self.ssl_with_SNI=0
    self.SNI_list=[]
    self.SNI_equal_DstIP=1
    #self.self_signed_cert=0

  #x509 features
    self.is_CN_in_SAN_list=[]
    self.is_SNI_in_san_dns=[]
    self.not_valid_certificate_number=0
    self.cert_percent_validity=[]
    self.certificate_serial_dict=dict()
    self.certificate_key_length_dict=dict()
    self.temp_list=[]
    self.certificate_valid_length=0
    self.certificate_valid_length_pow=0
    self.certificate_valid_number=0
    self.number_san_domains=0
    self.number_san_domains_index=0
    self.data=dict()

# connection main
  #ssl log is ssl record
  #ssl_flow=has ssl log in ssl file (conn record associate with any ssl reocrd)
  def add_ssl_flow(self, flow):
    self.ssl_flow_list.append(flow)
    self.compute_classic_features(flow)

  def add_ssl_flow_train(self, flow):
    if flow['label']=='malware':
      self.malware_label +=1
    else:
      self.normal_label +=1
    self.ssl_flow_list.append(flow)
    self.compute_classic_features(flow)

# ssl and x509 main
  def add_ssl_log(self, ssl_log, valid_x509_list): #ssl_log: a ssl line, valid_x509_list: list x509 record related with this ssl log
    for x509_record in valid_x509_list:
      self.compute_x509_features(x509_record)
      self.is_SNI_in_SAN(ssl_log, x509_record)
    self.compute_ssl_features(ssl_log)

    
#computing connection feature method
#uid: unique id of connection, Bro logs có sự liên kết giữa chúng với nhau thông qua các khóa duy nhất (unique key), mỗi dòng trong bất kỳ logs nào cũng đều có unique key liên kết đến các dòng khác trong phần còn lại của logs. 
  def compute_classic_features(self, flow):
    #count each uid in connection 4-tuple
    try:
      self.uid_flow_dict[flow['uid']]+=1
      print("Error: More same conn uids in compute_classic_features function")
    except:
      self.uid_flow_dict[flow['uid']]=1
    try:
      self.add_state_of_connection(flow['conn_state']) #split[11]: conn_state
      self.compute_size_of_flow(flow['orig_bytes'], flow['resp_bytes']) #split[10]:resp-bytes (Responder payload bytes; from sequence numbers if TCP), split[9]: orig_bytes (Originator payload bytes; from sequence numbers if TCP)
      duration=float(flow['duration']) #split[8]: duration (Time of last packet seen – time of first packet seen)
      self.process_duration(duration)
      self.inbound_packets += int(flow['resp_pkts']) #split[18]: resp_pkts (Number of RESP packets)
      self.outbound_packets += int(flow['orig_pkts']) #split[16]: orig_pkts (Number of ORIG packets)
    except:
      pass
 
  #count each state of connection in connection 4-tuple
  def add_state_of_connection(self, state):
    if state not in self.state_of_connection_dict.keys():
      self.state_of_connection_dict[state]=1
    else:
      self.state_of_connection_dict[state]+=1

  def process_duration(self, duration_value):
    self.flow_which_has_duration_number+=1
    self.duration_list.append(duration_value)
    self.average_duration+=duration_value #EX of duration
    self.agverage_duration_power+=pow(duration_value,2) # EX^2 of

  def compute_size_of_flow(self, orig_bytes, resp_bytes):
    try:
      orig_bytes_number=int(orig_bytes)
    except:
      if orig_bytes!='-':
        print("Error: orig_bytes has bad format")
      orig_bytes_number=0
    try:
      resp_bytes_number=int(resp_bytes)
    except:
      if resp_bytes!='-':
        print("Error: resp_bytes has bad format")
      resp_bytes_number=0
    self.list_payload_bytes_from_resp.append(resp_bytes_number)
    self.total_size_of_flows_orig+=orig_bytes_number
    self.total_size_of_flows_resp+=resp_bytes_number

#computing ssl features
  def compute_ssl_features(self, ssl_log):
    self.ssl_logs_list.append(ssl_log)
    self.ssl_uids_list.append(ssl_log['uid']) #split[1]: uid
    try:
      self.version_of_ssl_dict[ssl_log['version']]+=1 #split[6]:version, SSL version that the server offered
    except:
      self.version_of_ssl_dict[ssl_log['version']]=1

    try:
      self.version_of_ssl_cipher_dict[ssl_log['cipher']]+=1#split[7]:cipher, SSL cipher suite that the server choose
    except:
      self.version_of_ssl_cipher_dict[ssl_log['cipher']]=1
    if 'cert_chain_fps' in ssl_log and ssl_log['cert_chain_fps']: #split[14]: cert_chain_fuids, certificate path
      list_of_x509_uids=ssl_log['cert_chain_fps']
      try:
        self.certificate_path[len(list_of_x509_uids)]+=1
      except:
        self.certificate_path[len(list_of_x509_uids)]=1
    if 'server_name' in ssl_log:
      server_name=ssl_log['server_name']
      self.ssl_with_SNI+=1
      self.SNI_list.append(server_name)
      if self.SNI_equal_DstIP!=-1:
        try:
          socket.inet_aton(server_name)
          dstIP=self.tuple_index[1]
          print("SNI as IP: ", server_name," and destination ip is: ", dstIP)
          if(dstIP!=server_name):
            self.SNI_equal_DstIP=-1
          else:
            self.SNI_equal_DstIP=0
        except:
          pass
      # try:
      #   if 'signed certificate in certificate' in split[20]: #split[20]??????????
      #     self.self_signed_cert+=1
      # except:
      #   pass

#computing x509 features
  def compute_x509_features(self, valid_x509_line):
    self.x509_list.append(valid_x509_line)
    self.is_CN_in_SAN(valid_x509_line)
    
    #check if certificate valid during capture
    if valid_x509_line['certificate.not_valid_after']!='-' and valid_x509_line['certificate.not_valid_before']!='-': #split[6]: certificate_not_valid_before, split[7]: certificate_not_valid_after
      try:
        current_time=float(valid_x509_line['ts'])
        before_date=float(valid_x509_line['certificate.not_valid_before'])
        after_date=float(valid_x509_line['certificate.not_valid_after'])
        if current_time>after_date or current_time<before_date:
          self.not_valid_certificate_number+=1
        norm_after=after_date-before_date #time valid certificate
        current_time_norm=current_time-before_date #time valid certificate to now
        self.cert_percent_validity.append(current_time_norm/norm_after)
      except:
        print("Certificate time length is broken")
    if not (valid_x509_line['certificate.serial'] in self.certificate_serial_dict.keys()): #split[3]: certificate serial: serial number of certificate
      self.certificate_serial_dict[valid_x509_line['certificate.serial']]=1
      if valid_x509_line['certificate.key_length']!='-': #split[11]: certificate key length in bits
        try:
          self.certificate_key_length_dict[valid_x509_line['certificate.key_length']]+=1
        except:
          self.certificate_key_length_dict[valid_x509_line['certificate.key_length']]=1
      if valid_x509_line['certificate.not_valid_after']!='-' and valid_x509_line['certificate.not_valid_before']!='-':
        try:
          valid_length_sec=float(valid_x509_line['certificate.not_valid_after'])-float(valid_x509_line['certificate.not_valid_before'])
          valid_length_day_not_round=int(valid_length_sec/(3600*24))
          valid_length_day=round(valid_length_day_not_round,2)

          self.temp_list.append(valid_length_day)
          self.certificate_valid_length+=valid_length_day
          self.certificate_valid_length_pow+=pow(valid_length_day,2)
          self.certificate_valid_number+=1
        except:
          pass
      if 'san.dns' in valid_x509_line and valid_x509_line['san.dns']: #split[14]: san.dns: List of DNS entries in SAN
        domains=len(valid_x509_line['san.dns'])
        self.number_san_domains+=domains
        self.number_san_domains_index+=1
    else:
      self.certificate_serial_dict[valid_x509_line['certificate.serial']]+=1


  def get_periodicity_list(self):
    final_flow_list = self.ssl_flow_list
    flows_times_list = []
    for i in range(len(final_flow_list)):
      split = final_flow_list[i]
      flows_times_list.append(float(split['ts']))
    sorted_times_list = sorted(flows_times_list)
    T2_1 = None
    T2_2 = None
    T3 = None
    last_flow = None
    time_diff_list = []
    for i in range(len(sorted_times_list)):
      if last_flow == None:
        last_flow = sorted_times_list[i]
        continue
      if T2_1 == None:
        T2_1 = sorted_times_list[i] - last_flow
        last_flow = sorted_times_list[i]
        continue

      T2_2 = sorted_times_list[i] - last_flow
      T3 = abs(T2_2 - T2_1)
      T2_1 = T2_2
      last_flow = sorted_times_list[i]
      time_diff_list.append(T3)
    return time_diff_list

  def is_CN_in_SAN(self, x509_record):
    if 'san.dns' in x509_record and x509_record['san.dns']: #split[14]: san.dns: List of DNS entries in SAN
      CN_part=x509_record['certificate.subject'] #split[4]: CN
      SAN_dns_list=x509_record['san.dns']
      for i in range(len(SAN_dns_list)):
        if '*' in SAN_dns_list[i]:
          SAN_dns_list[i]=SAN_dns_list[i].replace('*', '')
      tmp=0
      # if all(san_dns in CN_part for san_dns in SAN_dns_list):
      #   tmp=1
      for san_dns in SAN_dns_list:
        if san_dns in CN_part:
          tmp=1
          break
      self.is_CN_in_SAN_list.append(tmp)
    
  def is_SNI_in_SAN(self, ssl_record, x509_record):
    if 'server_name' in ssl_record and ssl_record['server_name']!='-':
      server_name=ssl_record['server_name']
      if 'san.dns' in x509_record and x509_record['san.dns']: #x509_split[14]: san dns
        san_dns_list=x509_record['san.dns']
        for i in range(len(san_dns_list)):
          if '*' in san_dns_list[i]:
            san_dns_list[i]=san_dns_list[i].replace('*','')
        tmp=0
        for san_dns in san_dns_list:
          if san_dns in server_name:
            tmp=1
            break
        self.is_SNI_in_san_dns.append(tmp)
      
#GET FEATURES

  #feature 1
  def number_of_connection_records(self):
    return len(self.ssl_flow_list)
    #return self.number_+self.get_number_of_not_ssl_flows()
  #feature 2
  def mean_of_duration(self):
    if self.flow_which_has_duration_number !=0:
      return numpy.mean(self.duration_list)
      #return self.average_duration/self.flow_which_has_duration_number
    return -1
  #feature 3
  def standard_deviation_of_duration(self):
    if len(self.duration_list)!=0:
      return numpy.std(self.duration_list)
    return -1
  #feature 4
  def standard_deviation_range_duration(self):
    if len(self.duration_list)!=0:
      out_of_bounds=0
      lower_level=self.mean_of_duration()-self.standard_deviation_of_duration()
      higher_level=self.mean_of_duration()+self.standard_deviation_of_duration()
      for duration in self.duration_list:
        if duration<lower_level or duration>higher_level:
          out_of_bounds+=1
      return out_of_bounds/self.flow_which_has_duration_number
    return -1
  #feature 5
  def payload_bytes_from_originator(self):
    return self.total_size_of_flows_orig
  #feature 6
  def payload_bytes_from_responder(self):
    return self.total_size_of_flows_resp
  def mean_payload_bytes_from_responder(self):
    if self.list_payload_bytes_from_resp:
      return numpy.mean(self.list_payload_bytes_from_resp)
    return -1
  def standard_payload_bytes_from_responder(self):
    if self.list_payload_bytes_from_resp:
      return numpy.std(self.list_payload_bytes_from_resp)
    return -1
  #feature 7
  def ratio_of_responder_bytes(self):
    if self.total_size_of_flows_orig+self.total_size_of_flows_resp!=0:
      return self.total_size_of_flows_resp/(self.total_size_of_flows_orig+self.total_size_of_flows_resp)
    return -1
  #feature 8
  def ratio_established_states(self):
    established_states=0
    total_value_states=0
    for key in self.state_of_connection_dict.keys():
      total_value_states+=self.state_of_connection_dict[key]
    if total_value_states!=0:
      established_states+=self.state_of_connection_dict.get('SF',0)
      established_states+=self.state_of_connection_dict.get('S1',0)
      established_states+=self.state_of_connection_dict.get('S2',0)
      established_states+=self.state_of_connection_dict.get('S3',0)
      established_states+=self.state_of_connection_dict.get('RSTO',0)
      established_states+=self.state_of_connection_dict.get('RSTR',0)
      return established_states/total_value_states
    return -1
  #feature 9
  def get_inbound_packets(self):
    return self.inbound_packets
  #feature 10
  def get_outbound_packets(self):
    return self.outbound_packets
  #feature 11
  #def periodicity_mean(self):
  #feature 12
  #def standart_deviation_periodicity(self):
  def periodicity_mean(self):
    per_list = self.get_periodicity_list()
    sum = 0
    for i in range(len(per_list)):
      sum += per_list[i]
      if len(per_list) != 0:
        return sum / float(len(per_list))
        # print "periodicity list is zero. Number of flows:", self.get_number_of_flows()
    return -1

    # 14
  def standart_deviation_of_periodicity(self):
    per_list = self.get_periodicity_list()
    if len(per_list) != 0:
            # sum = 0
            # for i in range(len(per_list)):
            #     sum += pow(per_list[i], 2)
            # EX2 = sum / float(len(per_list))
            # DX = EX2 - EX * EX
            # return pow(DX, 0.5)
      return numpy.std(self.get_periodicity_list())
    return -1
  #feature 13
  def ratio_connection_record_ssl_aggregations(self):
    try:
      return (len(self.ssl_flow_list)-len(self.ssl_logs_list))/len(self.ssl_logs_list)
    except:
      return -1111
    #return len(self.not_ssl_flow_list)/len(self.ssl_flow_list)
  #feature 14
  def ratio_tls_ssl(self):
    tls=0
    ssl=0
    for key in self.version_of_ssl_dict.keys():
      if 'tls' in key.lower():
        tls+=self.version_of_ssl_dict[key]
      elif 'ssl' in key.lower():
        ssl+=self.version_of_ssl_dict[key]
    if tls+ssl==0:
      return -1
    return tls/(tls+ssl)
  #feature 15
  def ratio_sni(self):
    if len(self.ssl_logs_list)!=0:
      return self.ssl_with_SNI/len(self.ssl_logs_list)
    return -1
  def sni_as_ip(self):
    return self.SNI_equal_DstIP
  def mean_certificate_path(self):
    total_path=0
    count_certi_path=0
    for key in self.certificate_path.keys():
      total_path+=self.certificate_path[key]*int(key)
      count_certi_path+=self.certificate_path[key]
    if count_certi_path!=0:
      return total_path/count_certi_path
    return -1
  def ratio_self_signed_certificate(self):
    if len(self.ssl_logs_list)!=0:
      return self.self_signed_cert/len(self.ssl_logs_list)
    return -1
  def public_key_mean(self):
    total=0
    index=0
    for key in self.certificate_key_length_dict.keys():
      total+=self.certificate_key_length_dict[key]*int(key)
    for key in self.certificate_key_length_dict.keys():
      index+=self.certificate_key_length_dict[key]
    if index!=0:
      return total/index
    return -1
  def mean_certificate_validatity_periods(self):
    if self.certificate_valid_number!=0:
      if numpy.mean(self.temp_list)!=self.certificate_valid_length/self.certificate_valid_number:
        print("error: mean certificate length")
      return self.certificate_valid_length/self.certificate_valid_number
    return -1
  def standard_deviation_certificate_validatity_periods(self):
    if self.certificate_valid_number!=0:
      EX=self.certificate_valid_length/self.certificate_valid_number
      EX2=self.certificate_valid_length_pow/self.certificate_valid_number
      return pow(EX2-(EX*EX), 0.5)
    return -1
  def validity_certificate_period_during_capturing(self):
    return self.not_valid_certificate_number
  def mean_age_of_cert(self):
    if len(self.cert_percent_validity)!=0:
      tmp=0
      for i in self.cert_percent_validity:
        tmp+=i
      return tmp/len(self.cert_percent_validity)
    return -1
  def amount_of_certificates(self):
    return len(self.certificate_serial_dict.keys())
  def mean_number_of_domains_in_SAN_DNS(self):
    if self.number_san_domains_index!=0:
      return self.number_san_domains/self.number_san_domains_index
    return -1
  def ratio_certificate_records_SSL_records(self):
    if len(self.ssl_logs_list)!=0:
      return len(self.x509_list)/len(self.ssl_logs_list)
    return -1
  def sni_in_san_dns(self):
    if len(self.is_SNI_in_san_dns)!=0:
      for a in self.is_SNI_in_san_dns:
        if a==0:
          return 0
      return 1
    return -1
  def cn_in_san_dns(self):
    if len(self.is_CN_in_SAN_list)!=0:
      for a in self.is_CN_in_SAN_list:
        if a==0:
          return 0
      return 1
    return -1

  #GET METHOD
  def get_label_of_connection(self):
    if self.malware_label>self.normal_label:
      return 'MALWARE'
    else:
      return 'NORMAL'
  def is_malware(self):
    if self.malware_label > self.normal_label:
      return True
  def label_connection_number(self):
    if self.is_malware():
      return 1
    else:
      return 0  
  def get_label_of_connection(self):
    if self.malware_label>self.normal_label:
      return 1
    else:
      return 0
  def get_feature(self):
    data=dict()
    data['connection_index']=self.tuple_index
    data['number_of_connection_records']=self.number_of_connection_records()
    data['mean_of_duration']=self.mean_of_duration()
    data['standard_deviation_of_duration']=self.standard_deviation_of_duration()
    data['standard_deviation_range_duration']=self.standard_deviation_range_duration()
    data['payload_bytes_from_originator']=self.payload_bytes_from_originator()
    data['payload_bytes_from_responder']=self.payload_bytes_from_responder()
    # data['mean_payload_bytes_from_responder']=self.mean_payload_bytes_from_responder()
    # data['standard_payload_bytes_from_responder']=self.standard_payload_bytes_from_responder()
    data['ratio_of_responder_bytes']=self.ratio_of_responder_bytes()
    # data['ratio_established_states']=self.ratio_established_states()
    data['inbound_packets']=self.get_inbound_packets()
    data['outbound_packets']=self.get_outbound_packets()
    data['periodicity_mean']=self.periodicity_mean()
    data['standart_deviation_of_periodicity']=self.standart_deviation_of_periodicity()
    data['ratio_connection_record_ssl_aggregations']=self.ratio_connection_record_ssl_aggregations()
    data['ratio_tls_ssl']=self.ratio_tls_ssl()
    data['ratio_sni']=self.ratio_sni()
    # data['sni_as_ip']=self.sni_as_ip()
    data['mean_certificate_path']=self.mean_certificate_path()
    data['public_key_mean']=self.public_key_mean()
    data['mean_certificate_validatity_periods']=self.mean_certificate_validatity_periods()
    data['standard_deviation_certificate_validatity_periods']=self.standard_deviation_certificate_validatity_periods()
    # data['validity_certificate_period_during_capturing']=self.validity_certificate_period_during_capturing()
    data['mean_age_of_cert']=self.mean_age_of_cert()
    data['amount_of_certificates']=self.amount_of_certificates()
    data['mean_number_of_domains_in_SAN_DNS']=self.mean_number_of_domains_in_SAN_DNS()
    data['ratio_certificate_records_SSL_records']=self.ratio_certificate_records_SSL_records()
    # data['ratio_self_signed_certificate']=self.ratio_self_signed_certificate()
    data['sni_in_san_dns']=self.sni_in_san_dns()
    data['cn_in_san_dns']=self.cn_in_san_dns()
    return data
  def get_feature_in_train(self):
    data=self.get_feature()
    data['label']=self.get_label_of_connection()
    return data